# ?? v1.3.1: Type-Safe Variables & Parser Separation

> **Status:** ?? IN PROGRESS  
> **Priority:** HIGH  
> **Impact:** Architecture Improvement

---

## ? Part 1: Type-Safe Variables - PARTIALLY COMPLETE

### Completed:

1. ? **Created FDialogueVariant struct**
   - File: `DialogueVariant.h`
   - 7 types: Bool, Int, Float, String, Name, Object, Tag
   - Type-safe getters with auto-conversion
   - Blueprint library for BP support

2. ? **Created FDialogueVariant implementation**
   - File: `DialogueVariant.cpp`
   - All constructors
   - Type conversion logic
   - String serialization (ToString/FromString)
   - Comparison operators

3. ? **Added Type-Safe API to DialogueContext**
   - File: `DialogueContext.h`
   - SetVariantBool/Int/Float/String/Name/Object/Tag()
   - GetVariantBool/Int/Float/String/Name/Object/Tag()
   - Backward compatible with legacy string-based API

### TODO:

4. ? **Implement DialogueContext type-safe methods**
   - File: `DialogueContext.cpp`
   - Store variables as `TMap<FName, FDialogueVariant>`
   - Implement Get/Set methods
   - Keep backward compatibility with CustomVariables

5. ? **Update Effects to use type-safe API**
   - `UDialogueEffect_SetVariable` - use variants
   - `UDialogueEffect_SetMemory` - already type-safe (bool)
   - Update DSL parser to support typed variables

6. ? **Update Commands to use variants**
   - `UDialogueCommand_SetVariable` - use variants

7. ? **Testing**
   - Unit tests for FDialogueVariant
   - Integration tests with DialogueContext
   - Backward compatibility tests

---

## ?? Part 2: Parser Separation - NOT STARTED

### Plan:

1. ? **Create UDialogueEffectParser class**
   - File: `DialogueEffectParser.h/.cpp`
   - Move parsing logic from EffectExecutor
- ParseEffect(), ParseEffectList()
   - Tokenizer
   - Effect cache

2. ? **Refactor UDialogueEffectExecutor**
   - Remove parsing code
   - Keep only execution: ExecuteEffect(), ReverseEffect()
   - Clean separation of concerns

3. ? **Create UDialogueEffectSystem (Facade)**
   - Combines Parser + Executor
   - High-level API for users
   - ExecuteString() delegates to Parser + Executor

4. ? **Update Integration**
   - DialogueRunner uses EffectSystem
   - Commands use EffectSystem
   - Update documentation

---

## ?? Implementation Guide

### Step 4: DialogueContext Implementation

```cpp
// In DialogueContext.h (private section)
private:
    /** NEW v1.3.1: Type-safe variable storage */
    UPROPERTY(SaveGame)
    TMap<FName, FDialogueVariant> TypedVariables;
    
 // Helper: Convert variant to string for legacy API
    void SyncVariantToLegacy(FName Key, const FDialogueVariant& Value);

// In DialogueContext.cpp

#include "Core/DialogueVariant.h"

void UDialogueSessionContext::SetVariantBool(FName VariableName, bool Value)
{
    FDialogueVariant Variant = FDialogueVariant::MakeBool(Value);
   TypedVariables.Add(VariableName, Variant);
    
    // Sync to legacy CustomVariables for backward compatibility
    SyncVariantToLegacy(VariableName, Variant);
}

bool UDialogueSessionContext::GetVariantBool(FName VariableName, bool DefaultValue) const
{
    if (const FDialogueVariant* Variant = TypedVariables.Find(VariableName))
    {
        return Variant->GetBool(DefaultValue);
    }
    return DefaultValue;
}

void UDialogueSessionContext::SyncVariantToLegacy(FName Key, const FDialogueVariant& Value)
{
    // Keep CustomVariables in sync for backward compatibility
    CustomVariables.Add(Key, Value.ToString());
}

// Similar for Int, Float, String, etc.
```

### Step 5: Update Effects

```cpp
// In DialogueEffect_SetVariable
class UDialogueEffect_SetVariable : public UDialogueEffect
{
    // NEW v1.3.1
    UPROPERTY(EditAnywhere, Category = "Effect")
    EDialogueVariantType VariableType = EDialogueVariantType::String;
    
    UPROPERTY(EditAnywhere, Category = "Effect")
    FDialogueVariant Value;
    
  virtual void Execute_Implementation(UDialogueSessionContext* Context) override
    {
        // Use type-safe API
        switch (VariableType)
        {
        case EDialogueVariantType::Bool:
            Context->SetVariantBool(VariableKey, Value.GetBool());
            break;
        case EDialogueVariantType::Int:
            Context->SetVariantInt(VariableKey, Value.GetInt());
   break;
        // ... etc
 }
    }
};
```

---

## ?? Progress Tracker

| Task | Status | Priority | ETA |
|------|--------|----------|-----|
| FDialogueVariant struct | ? Complete | High | - |
| FDialogueVariant impl | ? Complete | High | - |
| DialogueContext API | ? Complete | High | - |
| DialogueContext impl | ? In Progress | High | 30min |
| Update Effects | ? Pending | Medium | 30min |
| Update Commands | ? Pending | Medium | 15min |
| Parser separation | ? Pending | Medium | 1h |
| Testing | ? Pending | High | 1h |
| Documentation | ? Pending | Medium | 30min |

---

## ?? Next Steps

**Immediate:**
1. Implement DialogueContext type-safe methods
2. Test basic get/set functionality
3. Ensure backward compatibility

**Then:**
4. Update Effects to use variants
5. Separate Parser from Executor
6. Full integration testing

**Finally:**
7. Update documentation
8. Create migration guide
9. Performance testing

---

## ?? Notes

- Backward compatibility is CRITICAL
- Legacy `CustomVariables` (TMap<FName, FString>) must still work
- Type conversion should be automatic where possible
- Document migration path for users

---

**Status:** 40% Complete  
**Next:** Implement DialogueContext type-safe methods  
**Blocker:** None
