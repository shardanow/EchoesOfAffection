# ?? System Workflows & Integration Patterns

> **Дата:** 2025-01-23  
> **Версия:** v1.3.1+  
> **Дополнение к:** Architecture_Analysis_And_Recommendations.md

---

## ?? Table of Contents

1. [Complete Dialogue Flow](#complete-dialogue-flow)
2. [Integration Patterns](#integration-patterns)
3. [Data Authoring Workflow](#data-authoring-workflow)
4. [Runtime Execution Flow](#runtime-execution-flow)
5. [Save/Load Workflow](#saveload-workflow)
6. [Error Handling & Recovery](#error-handling--recovery)
7. [Performance Considerations](#performance-considerations)

---

## 1. Complete Dialogue Flow

### 1.1. Interaction Detection & Initiation

```
???????????????
?   Player    ?
?  Movement   ?
???????????????
       ?
 v
????????????????????????????????
? InteractionComponent::Tick() ?
????????????????????????????????
? 1. TraceTimer += DeltaTime   ?
? 2. if (Timer > Interval)   ?
?    ??> FindInteractables()   ?
????????????????????????????????
       ?
       v
??????????????????????????????????
? FindInteractables()            ?
??????????????????????????????????
? 1. Get Camera Transform        ?
? 2. Sphere/Line Trace         ?
? 3. For each hit:        ?
?    ??> IsActorInteractable()  ?
? 4. Find closest valid actor    ?
? 5. UpdateFocusedInteractable() ?
??????????????????????????????????
       ?
       v
???????????????????????????????????
? IInteractableInterface          ?
? ::CanInteract()  ?
???????????????????????????????????
? NPC checks:  ?
? - DialogueCooldown > 0? ?
? - Already in dialogue?          ?
? - Distance check    ?
? - Custom conditions     ?
???????????????????????????????????
       ?
       ? [Player presses E]
       v
???????????????????????????????
? TryInteract()   ?
???????????????????????????????
? if (Interactable)        ?
?   ??> Execute_Interact()    ?
???????????????????????????????
       ?
       v
??????????????????????????????????
? IInteractableInterface         ?
? ::Execute_Interact()      ?
??????????????????????????????????
? UDialogueComponent::           ?
?   StartDialogue()       ?
??????????????????????????????????
       ?
       v
????????????????????????????????????
? DialogueSubsystem::StartDialogue ?
????????????????????????????????????
```

### 1.2. Dialogue Initialization & Asset Loading

```
???????????????????????????????????????
? DialogueSubsystem::StartDialogue()  ?
???????????????????????????????????????
? Input: ?
? - UDialogueDataAsset*       ?
? - AActor* Player        ?
? - AActor* NPC             ?
???????????????????????????????????????
       ?
    v
????????????????????????????????????????
? Validation     ?
????????????????????????????????????????
? ? Asset != nullptr        ?
? ? Player != nullptr   ?
? ? NPC != nullptr          ?
? ? NPC has DialogueComponent      ?
????????????????????????????????????????
       ?
 v
????????????????????????????????????????
? RunnerPool->AcquireRunner()       ?
????????????????????????????????????????
? If (AvailableRunners.Num() > 0)     ?
?   ??> Pop from available pool       ?
? Else if (ActiveRunners.Num() < Max) ?
?   ??> Create new runner      ?
? Else    ?
???> Wait or deny          ?
????????????????????????????????????????
   ?
  v
????????????????????????????????????????
? Runner->Initialize()       ?
????????????????????????????????????????
? 1. Create Context:         ?
? ??> NewObject<UDialogueSession   ?
?        Context>(Runner)    ?
?         ?
? 2. Initialize Components:            ?
?    ??> Context->Initialize()        ?
?        - State = NewObject<...>     ?
?        - Participants = NewObject   ?
?        - Variables = NewObject      ?
?       ?
? 3. Initialize Subsystems:            ?
?    ??> CommandInvoker (lazy)        ?
?    ??> StateMachine          ?
?     ?
? 4. Set Participants:         ?
?    ??> Context->SetPlayer(Player)   ?
?    ??> Context->SetNPC(NPC)         ?
????????????????????????????????????????
       ?
       v
????????????????????????????????????????
? Load Dialogue Asset         ?
????????????????????????????????????????
? if (Asset->IsAsyncLoadingMultithreaded()) ?
?   ??> LoadDialogueAsync()    ?
? else   ?
?   ??> LoadDialogueSync()            ?
????????????????????????????????????????
     ?
       ? [Async path]
       v
????????????????????????????????????????
? FStreamableManager::RequestAsync()   ?
????????????????????????????????????????
? 1. Add to PendingAsyncLoads (FIX!)  ?
? 2. Create TSharedPtr<FStreamable    ?
?    Request>       ?
? 3. Bind OnLoadComplete:    ?
?    ??> HandleAssetLoaded()       ?
? 4. Start async loading   ?
????????????????????????????????????????
       ?
       ? [On complete]
  v
????????????????????????????????????????
? HandleAssetLoaded()          ?
????????????????????????????????????????
? 1. Remove from PendingAsyncLoads    ?
? 2. Validate asset loaded          ?
? 3. Cache asset     ?
? 4. Broadcast OnDialogueLoaded        ?
? 5. Transition: Loading ? Active      ?
????????????????????????????????????????
       ?
       v
????????????????????????????????????????
? Runner->StartDialogue()              ?
????????????????????????????????????????
```

### 1.3. Node Processing & Choice Selection

```
??????????????????????????????????
? Runner->StartDialogue()        ?
??????????????????????????????????
? 1. StateMachine->TransitionTo( ?
?    EDialogueState::Active)     ?
?   ?
? 2. Find StartNode:  ?
?    ??> Asset->GetNodeById(     ?
?        "Start")         ?
?           ?
? 3. ProcessNode(StartNode)      ?
??????????????????????????????????
       ?
       v
??????????????????????????????????????????
? Runner->ProcessNode(Node)     ?
??????????????????????????????????????????
? 1. Validate state:             ?
?    ??> CanPerformOperation(Process)   ?
?  ?
? 2. State transition:        ?
?    ??> Active ? Transitioning         ?
?          ?
? 3. Set current node:           ?
?    ??> Context->SetCurrentNode(Node)  ?
?     ?
? 4. Mark visited:        ?
?    ??> Context->MarkNodeVisited(Id)   ?
?  ?
? 5. Add to history:          ?
?    ??> Context->AddToHistory(...)     ?
?       ?
? 6. Handle node type:       ?
?    ??> if (Dialogue) ? Filter choices ?
?    ??> if (Branch) ? Auto-navigate    ?
???> if (End) ? End dialogue        ?
? ?
? 7. State transition: ?
?    ??> Transitioning ? Active      ?
??
? 8. Broadcast events:           ?
?    ??> OnNodeChanged(NewNode, Old)    ?
????????????????????????????????????????????
       ?
 v
???????????????????????????????????????????
? Filter Choices (Evaluate Conditions)  ?
???????????????????????????????????????????
? TArray<FDialogueChoice> ValidChoices;   ?
?            ?
? For each choice in Node->Choices:   ?
?   ??> Evaluate ALL conditions          ?
?   ?   ??> ConditionEvaluator->Evaluate ?
?   ?       (Choice.Conditions, Context)  ?
?   ?             ?
?   ??> if (all pass)             ?
?       ??> ValidChoices.Add(Choice)     ?
?               ?
? OnChoicesAvailable.Broadcast(Valid)    ?
???????????????????????????????????????????
?
       v
??????????????????????????????????
? UI->ShowChoices(ValidChoices)  ?
??????????????????????????????????
? For each ValidChoice:          ?
?   ??> Create UChoiceButton:   ?
?       - Set text          ?
?       - Bind OnClicked ?     ?
?         Runner->SelectChoice() ?
??????????????????????????????????
       ?
       ? [Player clicks choice]
  v
????????????????????????????????????????
? Runner->SelectChoice(Index)       ?
????????????????????????????????????????
? 1. Validate state & index     ?
?     ?
? 2. Get selected choice  ?
?         ?
? 3. Create command:            ?
?    ??> UDialogueCommand_SelectChoice ?
?        - ChoiceIndex        ?
?   - ChoiceData       ?
?        - Snapshot (optional)         ?
?          ?
? 4. Execute command:      ?
?    ??> Runner->ExecuteCommand(Cmd)  ?
????????????????????????????????????????
  ?
       v
????????????????????????????????????????
? Command_SelectChoice::Execute()      ?
????????????????????????????????????????
? 1. Apply effects:    ?
?    ??> For each effect in choice:   ?
?        ??> EffectExecutor->Apply()  ?
?             ?
? 2. Navigate to target:               ?
?    ??> Runner->GoToNode(TargetId)   ?
?        ?
? 3. Record in history (auto)    ?
????????????????????????????????????????
       ?
       v
????????????????????????????????????????
? Runner->GoToNode(NodeId)        ?
????????????????????????????????????????
? 1. Find node in asset          ?
?       ?
? 2. Create navigation command:      ?
?    ??> Command_NavigateToNode       ?
?                  ?
? 3. Execute command:?
?    ??> ProcessNode(TargetNode)      ?
? ?
? 4. [Loop back to ProcessNode]       ?
????????????????????????????????????????
```

### 1.4. Effects Application

```
????????????????????????????????????????
? EffectExecutor->ApplyEffects()       ?
????????????????????????????????????????
? Input: TArray<FDialogueEffect>       ?
????????????????????????????????????????
       ?
       v
????????????????????????????????????????
? For each effect:             ?
?          ?
? 1. Resolve effect type    ?
? 2. Get implementation:         ?
?    ??> GetEffectImplementation(Type) ?
? 3. Call Apply(Context)       ?
????????????????????????????????????????
       ?
       ??> ModifyAffinity
       ?   ????????????????????????????????
  ?   ? Get NPC RelationshipComponent?
       ?   ? RelComp->ModifyAffinity(?)   ?
  ?   ? Create memory entry  ?
       ?   ????????????????????????????????
       ?
  ??> SetVariable
     ?   ????????????????????????????????
       ?   ? Context->GetVariables()->    ?
       ?   ?   SetVariantInt(Key, Value)  ?
       ?   ????????????????????????????????
       ?
       ??> AddTag
       ?   ????????????????????????????????
       ?   ? Context->GetVariables()->    ?
   ?   ?   AddTag(Tag)        ?
       ?   ????????????????????????????????
       ?
       ??> StartQuest
       ?   ????????????????????????????????
 ?   ? QuestSubsystem->StartQuest() ?
       ?   ? Create promise memory     ?
       ?   ????????????????????????????????
    ?
       ??> ModifyInventory
       ?   ????????????????????????????????
       ?   ? InventoryComp->AddItem() or  ?
       ?   ? InventoryComp->RemoveItem()  ?
       ?   ? Create item memory ?
       ?   ????????????????????????????????
       ?
       ??> Composite
 ????????????????????????????????
           ? For each sub-effect:         ?
     ?   ??> ApplyEffect(SubEffect) ?
        ????????????????????????????????
```

### 1.5. Dialogue End & Cleanup

```
??????????????????????????????????
? Node type == End          ?
???> Runner->EndDialogue()   ?
??????????????????????????????????
       ?
       v
????????????????????????????????????????
? Runner->EndDialogue()         ?
????????????????????????????????????????
? 1. Validate state:        ?
?    ??> if (State != Active)        ?
?        return        ?
? ?
? 2. Transition state:            ?
?    ??> StateMachine->TransitionTo(  ?
?        EDialogueState::Ended)        ?
?      ?
? 3. Save state (optional):     ?
?    ??> AutoSave if enabled           ?
?       ?
? 4. Notify participants:   ?
?    ??> DialogueComponent->           ?
?        OnDialogueEnded()             ?
?      ?
? 5. Broadcast events:                 ?
?    ??> OnDialogueEnded.Broadcast()  ?
?    ??> Subsystem->OnAnyDialogue     ?
?        Ended.Broadcast()        ?
?      ?
? 6. UI cleanup:       ?
?    ??> HideDialogueWidget()?
?    ?
? 7. Camera cleanup:            ?
?    ??> RestorePlayerCamera()        ?
?      ?
? 8. Return to pool:          ?
?    ??> Subsystem->ReleaseRunner()   ?
????????????????????????????????????????
       ?
       v
????????????????????????????????????????
? RunnerPool->ReleaseRunner(Runner)    ?
????????????????????????????????????????
? 1. Reset runner state:       ?
?    ??> Runner->Reset()     ?
?        - Clear context    ?
?        - Clear command history       ?
?        - Reset state machine         ?
?          ?
? 2. Move to available pool:           ?
?    ??> ActiveRunners.Remove(Runner) ?
?    ??> AvailableRunners.Add(Runner) ?
?         ?
? 3. Update pool stats    ?
????????????????????????????????????????
```

---

## 2. Integration Patterns

### 2.1. Interaction ? Dialogue Integration

**Pattern:** Interface-based decoupling

```cpp
// 1. NPC implements interfaces
UCLASS()
class ANPC : public ACharacter, 
     public IInteractableInterface,
       public IDialogueParticipant
{
    UPROPERTY()
    UDialogueComponent* DialogueComponent;
    
    UPROPERTY()
    URelationshipComponent* RelationshipComponent;
    
    UPROPERTY()
    UNPCMemoryComponent* MemoryComponent;
};

// 2. Player's InteractionComponent detects NPC
void UInteractionComponent::FindInteractables()
{
    // Sphere trace
    if (HitActor->Implements<UInteractableInterface>())
    {
        IInteractableInterface* Interactable = Cast<IInteractableInterface>(HitActor);
      if (Interactable->Execute_CanInteract(HitActor, GetOwner()))
        {
      UpdateFocusedInteractable(HitActor);
        }
    }
}

// 3. Player initiates interaction
void UInteractionComponent::TryInteract()
{
    if (FocusedActor)
    {
        IInteractableInterface::Execute_Interact(FocusedActor, GetOwner());
 }
}

// 4. NPC starts dialogue
void ANPC::Interact_Implementation(AActor* Initiator)
{
    if (DialogueComponent)
{
        DialogueComponent->StartDialogue(Initiator);
    }
}

// 5. DialogueComponent delegates to Subsystem
void UDialogueComponent::StartDialogue(AActor* Player)
{
    UDialogueSubsystem* Subsystem = GetWorld()->GetGameInstance()
     ->GetSubsystem<UDialogueSubsystem>();
    
    Subsystem->StartDialogue(DefaultDialogue, Player, GetOwner());
}
```

**Benefits:**
- ? No tight coupling between Interaction and Dialogue
- ? NPC doesn't need to know about InteractionComponent
- ? Can swap implementations easily
- ? Testable in isolation

---

### 2.2. Dialogue ? Relationship Integration

**Pattern:** Effect-based modification

```cpp
// 1. Designer defines effect in DataAsset
Choice "Help the villagers"
  Effect: ModifyAffinity +30
  Effect: ModifyTrust +20
  Effect: AddTag "Hero.Helpful"

// 2. Effect applied during dialogue
void UDialogueEffect_ModifyAffinity::Apply(UDialogueSessionContext* Context)
{
    AActor* NPC = Context->GetNPC();
    if (!NPC) return;
    
    // Find relationship component (no hard dependency)
    URelationshipComponent* RelComp = NPC->FindComponentByClass<URelationshipComponent>();
    if (!RelComp) return;
    
  // Apply modification
    RelComp->ModifyAffinity(AffinityDelta);
    
    // Optional: Create memory
    if (UNPCMemoryComponent* MemComp = NPC->FindComponentByClass<UNPCMemoryComponent>())
    {
        MemComp->CreateMemory(
            EMemoryType::RelationshipChange,
     FText::Format(LOCTEXT("AffinityChanged", "Affinity changed by {0}"), AffinityDelta),
            FMath::Abs(AffinityDelta),
            AffinityDelta > 0 ? EMemoryEmotion::Positive : EMemoryEmotion::Negative,
   Context->GetPlayer()
        );
    }
}

// 3. Relationship component processes change
void URelationshipComponent::ModifyAffinity(float Delta)
{
    // Apply personality modifiers
    if (Delta > 0)
        Delta *= PositiveSensitivity;
    else
        Delta *= NegativeSensitivity;
    
    // Update value
    Affinity = FMath::Clamp(Affinity + Delta, -100.0f, 100.0f);
    
    // Check threshold changes
  UpdateRelationshipRank();
    
    // Broadcast event
    OnAffinityChanged.Broadcast(Affinity, Delta);
}
```

**Benefits:**
- ? One-way dependency (Dialogue ? Relationship)
- ? Relationship is reusable outside dialogue
- ? Easy to add new relationship metrics
- ? Data-driven design

---

### 2.3. Dialogue ? Memory Integration

**Pattern:** Automatic memory creation + condition queries

```cpp
// 1. DialogueComponent automatically creates memories
void UDialogueComponent::HandleNodeEntered(UDialogueNode* Node)
{
    if (!MemoryComp || !Node) return;
    
    // Create memory for significant dialogue events
    float Importance = CalculateImportance(Node);
    if (Importance > MinimumImportanceThreshold)
    {
      FNPCMemoryEntry Memory;
     Memory.Type = EMemoryType::DialogueEvent;
        Memory.Description = Node->SpeakerText;
        Memory.Importance = Importance;
        Memory.Emotion = DetermineEmotion(Node);
        Memory.RelatedActor = LastContext->GetPlayer();
        
        // Add context tags from node
        for (FGameplayTag Tag : Node->ContextTags)
        {
            Memory.ContextTags.AddTag(Tag);
        }
        
MemoryComp->AddMemory(Memory);
    }
}

// 2. Conditions check memory
bool UDialogueCondition_MemoryCheck::Evaluate(UDialogueSessionContext* Context)
{
    AActor* NPC = Context->GetNPC();
    UNPCMemoryComponent* MemComp = NPC->FindComponentByClass<UNPCMemoryComponent>();
    if (!MemComp) return false;
    
  // Query memories
    TArray<FNPCMemoryEntry> Memories;
    
    switch (QueryType)
    {
      case EMemoryQueryType::HasTag:
            Memories = MemComp->FindMemoriesWithTag(RequiredTag);
            break;
            
        case EMemoryQueryType::AboutActor:
   Memories = MemComp->GetMemoriesAboutActor(Context->GetPlayer());
       break;
            
        case EMemoryQueryType::RecentEvents:
    Memories = MemComp->GetRecentMemories(MaxAgeDays);
         break;
    }
    
    return Memories.Num() >= MinimumCount;
}

// 3. Effects can modify memory
void UDialogueEffect_ModifyMemory::Apply(UDialogueSessionContext* Context)
{
    AActor* NPC = Context->GetNPC();
    UNPCMemoryComponent* MemComp = NPC->FindComponentByClass<UNPCMemoryComponent>();
    if (!MemComp) return;
  
    switch (ModificationType)
    {
        case EMemoryModification::Create:
            MemComp->CreateMemory(MemoryType, Description, Importance, Emotion, Context->GetPlayer());
     break;
        
   case EMemoryModification::Reinforce:
         MemComp->ReinforceMemory(MemoryId, ImportanceDelta);
            break;
      
     case EMemoryModification::Fade:
     MemComp->FadeMemory(MemoryId, ImportanceDelta);
       break;
   
        case EMemoryModification::Remove:
        MemComp->RemoveMemory(MemoryId);
         break;
    }
}
```

**Benefits:**
- ? Automatic memory creation (no manual work)
- ? Conditions can query rich memory data
- ? Effects can manipulate memories
- ? Supports complex narrative scenarios

---

### 2.4. Dialogue ? Quest Integration (Future)

**Pattern:** Effect-based quest triggers + condition queries

```cpp
// 1. Quest system interface
UINTERFACE()
class UQuestSystemInterface : public UInterface
{
    GENERATED_BODY()
};

class IQuestSystemInterface
{
    GENERATED_BODY()
    
public:
    UFUNCTION(BlueprintNativeEvent)
    void StartQuest(FName QuestId);
    
    UFUNCTION(BlueprintNativeEvent)
    void CompleteQuest(FName QuestId);
    
    UFUNCTION(BlueprintNativeEvent)
    bool IsQuestActive(FName QuestId) const;
    
    UFUNCTION(BlueprintNativeEvent)
    bool IsQuestCompleted(FName QuestId) const;
};

// 2. Effect implementation
void UDialogueEffect_StartQuest::Apply(UDialogueSessionContext* Context)
{
    // Find quest system (via interface)
    UGameInstance* GI = Context->GetWorld()->GetGameInstance();
    if (IQuestSystemInterface* QuestSystem = Cast<IQuestSystemInterface>(GI))
    {
        // Start quest
   QuestSystem->Execute_StartQuest(Cast<UObject>(QuestSystem), QuestId);
        
        // Create promise memory
        AActor* NPC = Context->GetNPC();
        if (UNPCMemoryComponent* MemComp = NPC->FindComponentByClass<UNPCMemoryComponent>())
    {
 MemComp->CreateMemory(
     EMemoryType::Promise,
    FText::Format(LOCTEXT("QuestStarted", "Promised to help with {0}"), QuestName),
        95.0f, // Very important
 EMemoryEmotion::Neutral,
         Context->GetPlayer()
            );
        }
    }
}

// 3. Condition implementation
bool UDialogueCondition_QuestCompleted::Evaluate(UDialogueSessionContext* Context)
{
    UGameInstance* GI = Context->GetWorld()->GetGameInstance();
    if (IQuestSystemInterface* QuestSystem = Cast<IQuestSystemInterface>(GI))
    {
        return QuestSystem->Execute_IsQuestCompleted(Cast<UObject>(QuestSystem), QuestId);
    }
    return false;
}

// 4. Usage in DataAsset
Choice "I've completed the task"
  Condition: QuestCompleted "Quest_FindSister"
  Effect: ModifyAffinity +50
  Effect: ModifyTrust +40
  Effect: CompleteQuest "Quest_FindSister"
  Effect: StartQuest "Quest_Reward"
  Goto: "Node_ThankYou"
```

**Benefits:**
- ? Interface-based (no hard dependency)
- ? Works with any quest system
- ? Bidirectional integration (check + modify)
- ? Memory system tracks promises

---

### 2.5. Dialogue ? AI Integration (Future)

**Pattern:** Provider-based async generation

```cpp
// 1. AI Provider Interface
UINTERFACE()
class UAIDialogueProviderInterface : public UInterface
{
    GENERATED_BODY()
};

class IAIDialogueProviderInterface
{
    GENERATED_BODY()
    
public:
    UFUNCTION(BlueprintNativeEvent)
    void GenerateResponse(
        const FString& NPCPersonality,
        const FString& DialogueContext,
        const FString& PlayerMessage,
        const FOnAIResponseGenerated& Callback
    );
    
    UFUNCTION(BlueprintNativeEvent)
    bool IsAvailable() const;
};

// 2. Implementation (OpenAI example)
class UOpenAIDialogueProvider : public UObject, public IAIDialogueProviderInterface
{
public:
    virtual void GenerateResponse_Implementation(
    const FString& NPCPersonality,
        const FString& DialogueContext,
        const FString& PlayerMessage,
        const FOnAIResponseGenerated& Callback
    ) override
    {
        // 1. Build prompt
  FString Prompt = FString::Printf(TEXT(
    "You are %s. Context: %s. Player said: \"%s\". Respond in character:"
        ), *NPCPersonality, *DialogueContext, *PlayerMessage);
 
   // 2. Create HTTP request
        TSharedRef<IHttpRequest> Request = FHttpModule::Get().CreateRequest();
        Request->SetURL(TEXT("https://api.openai.com/v1/chat/completions"));
        Request->SetVerb(TEXT("POST"));
     Request->SetHeader(TEXT("Authorization"), FString::Printf(TEXT("Bearer %s"), *APIKey));
   Request->SetHeader(TEXT("Content-Type"), TEXT("application/json"));
  
        // 3. Build JSON payload
        TSharedPtr<FJsonObject> JsonObject = MakeShareable(new FJsonObject);
      JsonObject->SetStringField(TEXT("model"), TEXT("gpt-4"));
        // ... (add messages, parameters)
        
        FString RequestBody;
     TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&RequestBody);
        FJsonSerializer::Serialize(JsonObject.ToSharedRef(), Writer);
        Request->SetContentAsString(RequestBody);
        
   // 4. Bind callback
      Request->OnProcessRequestComplete().BindLambda([Callback](
            FHttpRequestPtr Request,
            FHttpResponsePtr Response,
            bool bSuccess
        ) {
    if (bSuccess && Response.IsValid())
            {
    // Parse response
                TSharedPtr<FJsonObject> JsonResponse;
             TSharedRef<TJsonReader<>> Reader = TJsonReaderFactory<>::Create(Response->GetContentAsString());
      
                if (FJsonSerializer::Deserialize(Reader, JsonResponse))
          {
           FString AIResponse = JsonResponse->GetStringField(TEXT("choices[0].message.content"));
         
      // Execute callback on game thread
   AsyncTask(ENamedThreads::GameThread, [Callback, AIResponse]() {
            Callback.ExecuteIfBound(AIResponse, true);
          });
       }
            }
            else
      {
             // Error handling
        AsyncTask(ENamedThreads::GameThread, [Callback]() {
          Callback.ExecuteIfBound(TEXT(""), false);
   });
         }
 });
        
        // 5. Send request
        Request->ProcessRequest();
    }
};

// 3. Usage in DialogueRunner
void UDialogueRunner::ProcessDynamicChoice(FDialogueChoice Choice)
{
    // Check if AI provider available
    IAIDialogueProviderInterface* AIProvider = GetAIProvider();
    if (!AIProvider || !AIProvider->Execute_IsAvailable(Cast<UObject>(AIProvider)))
    {
        // Fallback to static dialogue
        ProcessStaticChoice(Choice);
        return;
    }
    
    // Build context for AI
    FString Personality = BuildNPCPersonality();
    FString Context = BuildDialogueContext();
    FString PlayerMessage = Choice.Text.ToString();
    
  // Request AI generation
 FOnAIResponseGenerated Callback;
    Callback.BindUObject(this, &UDialogueRunner::HandleAIResponse);
    
    AIProvider->Execute_GenerateResponse(
   Cast<UObject>(AIProvider),
      Personality,
        Context,
        PlayerMessage,
 Callback
    );
}

void UDialogueRunner::HandleAIResponse(const FString& Response, bool bSuccess)
{
    if (bSuccess)
    {
        // Create dynamic node
        UDialogueNode* DynamicNode = NewObject<UDialogueNode>(this);
    DynamicNode->NodeId = FName(*FGuid::NewGuid().ToString());
        DynamicNode->SpeakerText = FText::FromString(Response);
        DynamicNode->Type = EDialogueNodeType::Dialogue;
        
   // Process node
        ProcessNode(DynamicNode);
    }
    else
    {
      // Fallback or error handling
        UE_LOG(LogDialogue, Error, TEXT("AI response generation failed"));
    }
}

// 4. Build context helper
FString UDialogueRunner::BuildDialogueContext() const
{
    TArray<FString> ContextParts;
    
    // 1. Relationship info
    if (URelationshipComponent* RelComp = GetNPCRelationshipComponent())
    {
        ContextParts.Add(FString::Printf(TEXT("Affinity: %.0f"), RelComp->GetAffinity()));
        ContextParts.Add(FString::Printf(TEXT("Trust: %.0f"), RelComp->GetTrust()));
        ContextParts.Add(FString::Printf(TEXT("Relationship: %s"), *RelComp->GetRelationshipRank().ToString()));
    }
 
    // 2. Recent memories
    if (UNPCMemoryComponent* MemComp = GetNPCMemoryComponent())
    {
        TArray<FNPCMemoryEntry> Recent = MemComp->GetRecentMemories(7);
        for (const FNPCMemoryEntry& Memory : Recent)
        {
            ContextParts.Add(FString::Printf(TEXT("Memory: %s"), *Memory.Description.ToString()));
        }
    }
    
  // 3. Active tags
    FGameplayTagContainer Tags = Context->GetVariables()->GetActiveTags();
    for (FGameplayTag Tag : Tags)
 {
   ContextParts.Add(FString::Printf(TEXT("Tag: %s"), *Tag.ToString()));
    }
    
    // 4. Conversation history
    TArray<FDialogueHistoryEntry> History = Context->GetState()->GetConversationHistory();
    int32 HistoryCount = FMath::Min(5, History.Num());
    for (int32 i = History.Num() - HistoryCount; i < History.Num(); ++i)
    {
        ContextParts.Add(FString::Printf(TEXT("%s: %s"), 
        *History[i].SpeakerName.ToString(),
            *History[i].DialogueText.ToString()
        ));
    }
    
return FString::Join(ContextParts, TEXT("\n"));
}
```

**Benefits:**
- ? Async request (non-blocking)
- ? Pluggable providers (OpenAI, Claude, local LLM)
- ? Rich context (relationships, memories, history)
- ? Fallback to static dialogue
- ? Game thread safety

---

## 3. Data Authoring Workflow

### 3.1. DataAsset Creation (Designer Workflow)

```
???????????????????????????????????
? Content Browser          ?
? Right-Click ? Miscellaneous ?  ?
? Data Asset ? UDialogueDataAsset ?
???????????????????????????????????
       ?
  v
??????????????????????????????????????
? DialogueDataAsset Editor           ?
??????????????????????????????????????
? Dialogue Name: "Greeting_Villager" ?
? Description: "Initial greeting"    ?
?      ?
? Nodes: [+] Add Node     ?
? ?? Node_Start           ?
? ?? Node_AskAboutVillage ?
? ?? Node_AskAboutQuest    ?
? ?? Node_Goodbye             ?
??????????????????????????????????????
```

#### Node Configuration

```
??????????????????????????????????????????
? Node: Node_Start          ?
??????????????????????????????????????????
? Type: Dialogue     ?
? NodeId: "Start"         ?
?         ?
? Speaker: {NPC}            ?
? Speaker Text: "Hello traveler! Welcome?
?   to our village."    ?
?         ?
? Choices:          ?
? ?? [+] Add Choice         ?
? ?   ?? Text: "Tell me about the       ?
? ?   ?    village"             ?
? ?   ?? Target: "Node_AskAboutVillage" ?
? ?   ?        ?
? ?   ?? Conditions: [+] Add             ?
? ?       ?? HasTag: Player.Curious      ?
? ?       ?? AffinityCheck >= 0          ?
? ?       ?
? ?? [+] Add Choice          ?
? ?   ?? Text: "Do you need help?"      ?
? ?   ?? Target: "Node_AskAboutQuest"   ?
? ?   ?     ?
? ?   ?? Effects: [+] Add             ?
? ?       ?? ModifyAffinity: +10      ?
? ?     ?
? ?? [+] Add Choice      ?
?     ?? Text: "Goodbye"          ?
?     ?? Target: "Node_Goodbye"          ?
??????????????????????????????????????????
```

### 3.2. DSL Authoring (Alternative)

```
?????????????????????????????????
? Text Editor    ?
? File: Greeting_Villager.dlg   ?
?????????????????????????????????
DIALOGUE "Greeting_Villager"
DESCRIPTION "Initial greeting with villager"

NODE Start
  SPEAKER NPC
  TEXT "Hello traveler! Welcome to our village."
  
  CHOICE "Tell me about the village"
    CONDITION HasTag Player.Curious
    CONDITION AffinityCheck >= 0
    GOTO AskAboutVillage
  
  CHOICE "Do you need help?"
    EFFECT ModifyAffinity +10
    GOTO AskAboutQuest
  
CHOICE "Goodbye"
GOTO Goodbye

NODE AskAboutVillage
  SPEAKER NPC
  TEXT "We're a peaceful farming community..."
  
  CHOICE "Interesting"
    EFFECT AddTag World.VillageKnown
    GOTO Start
  
  CHOICE "Goodbye"
    GOTO Goodbye

NODE AskAboutQuest
  SPEAKER NPC
  TEXT "Yes! We need someone brave..."
  
  CHOICE "I'll help"
    EFFECT StartQuest "Quest_HelpVillage"
    EFFECT ModifyAffinity +30
    GOTO QuestAccepted
  
  CHOICE "Not interested"
    EFFECT ModifyAffinity -10
    GOTO Goodbye

NODE Goodbye
  TYPE End
  SPEAKER NPC
  TEXT "Safe travels, friend!"
?????????????????????????????????
       ?
       v
?????????????????????????????????
? DSL Parser       ?
? DSLParser->Parse("file.dlg")  ?
?????????????????????????????????
? 1. Tokenize              ?
? 2. Parse syntax          ?
? 3. Validate structure       ?
? 4. Create DataAsset       ?
? 5. Save asset           ?
?????????????????????????????????
```

---

## 4. Runtime Execution Flow

### 4.1. Command Execution with Undo

```
??????????????????????????????????
? Runner->ExecuteCommand(Cmd)    ?
??????????????????????????????????
    ?
       v
????????????????????????????????????????
? CommandInvoker->ExecuteCommand()  ?
????????????????????????????????????????
? 1. Check CanExecute():        ?
?    ??> Cmd->CanExecute(Runner)      ?
? ?
? 2. Create snapshot (if needed):     ?
?    ??> Cmd->SetSnapshot(            ?
?   Context->CreateSnapshot())    ?
?      ?
? 3. Execute command:       ?
?    ??> Cmd->Execute(Runner)         ?
?       ?
? 4. Record in history:      ?
?    ??> History->PushCommand(Cmd)    ?
?     ?
? 5. Clear redo stack                  ?
????????????????????????????????????????
    ?
       ? [Later: Player wants to undo]
v
????????????????????????????????????????
? Runner->UndoLastCommand()      ?
????????????????????????????????????????
? 1. Pop command from history          ?
?      ?
? 2. Execute undo: ?
?    ??> Cmd->Undo(Runner)             ?
?        ??> Try reverse effects       ?
?        ??> Fallback to snapshot      ?
?     ?
? 3. Push to redo stack    ?
????????????????????????????????????????
  ?
       ? [Player wants to redo]
       v
????????????????????????????????????????
? Runner->RedoCommand()         ?
????????????????????????????????????????
? 1. Pop command from redo stack  ?
?                  ?
? 2. Execute again:         ?
?    ??> Cmd->Execute(Runner)         ?
?       ?
? 3. Push back to history      ?
????????????????????????????????????????
```

### 4.2. State Machine Transitions

```
State Transition Rules:
?????????????????????????????????????????

Idle:
  ? Loading (StartDialogue)
  ? Error (on failure)

Loading:
  ? Active (asset loaded successfully)
  ? Error (load failed)
  ? Idle (cancelled)

Active:
  ? Paused (pause requested)
  ? Transitioning (node navigation)
  ? Ended (end node reached)
  ? Error (on error)

Paused:
  ? Active (resume)
  ? Ended (force end)

Transitioning:
  ? Active (navigation complete)
  ? Error (navigation failed)

Ended:
  ? Idle (reset/restart)

Error:
  ? Idle (reset)

Operation Permissions:
??????????????????????????????????????????

ProcessNode: Active, Transitioning
SelectChoice: Active
GoToNode: Active, Transitioning
StartDialogue: Idle, Ended
EndDialogue: Active, Paused
PauseDialogue: Active
ResumeDialogue: Paused
```

---

## 5. Save/Load Workflow

### 5.1. Save Process

```
??????????????????????????????????
? Trigger Save   ?
? (Manual or Auto)           ?
??????????????????????????????????
       ?
       v
????????????????????????????????????????
? Context->ToSaveData(DialogueId)  ?
????????????????????????????????????????
? Create FDialogueSessionSaveData:     ?
?           ?
? 1. Basic Info:  ?
?    ??> DialogueId          ?
?  ??> Timestamp          ?
?        ?
? 2. State Data:   ?
?    ??> CurrentNodeId      ?
?    ??> VisitedNodes      ?
?    ??> ConversationHistory           ?
?     ?
? 3. Variables:              ?
?  ??> CustomVariables (TMap)       ?
?    ??> TypedVariables (TMap)      ?
?    ??> ActiveTags          ?
?          ?
? 4. Participants:      ?
?    ??> BaseAffinityLevel  ?
???> (Player/NPC refs not saved)  ?
????????????????????????????????????????
       ?
       v
????????????????????????????????????????
? UDialogueSaveGame        ?
? ::SaveDialogueSession()   ?
????????????????????????????????????????
? 1. Find or create slot:          ?
?    ??> DialogueSessions.FindOrAdd() ?
?  ?
? 2. Store save data:        ?
?    ??> Sessions[Key] = SaveData     ?
?            ?
? 3. Mark as dirty         ?
????????????????????????????????????????
       ?
   v
????????????????????????????????????????
? UGameplayStatics::SaveGameToSlot()   ?
????????????????????????????????????????
? Platform-specific save    ?
????????????????????????????????????????
```

### 5.2. Load Process

```
??????????????????????????????????
? Load Game           ?
??????????????????????????????????
       ?
       v
????????????????????????????????????????
? UGameplayStatics::LoadGameFromSlot() ?
????????????????????????????????????????
       ?
       v
????????????????????????????????????????
? UDialogueSaveGame::LoadDialogue      ?
? Session(DialogueId)  ?
????????????????????????????????????????
? 1. Find save data:   ?
?    ??> Sessions.Find(DialogueId)    ?
??
? 2. Return FDialogueSessionSaveData   ?
????????????????????????????????????????
       ?
       v
????????????????????????????????????????
? Context->FromSaveData(SaveData,      ?
? Player, NPC)     ?
????????????????????????????????????????
? 1. Restore State:         ?
?    ??> State->SetCurrentNode(...)   ?
?    ??> State->SetVisitedNodes(...)  ?
?    ??> State->SetHistory(...)       ?
?  ?
? 2. Restore Variables:       ?
?    ??> Variables->SetAll(...)       ?
?    ??> Variables->SetTags(...)      ?
?      ?
? 3. Set Participants:      ?
?    ??> Participants->SetPlayer(...)  ?
?    ??> Participants->SetNPC(...)?
?    ??> Participants->SetAffinity(...) ?
? ?
? 4. Validate integrity  ?
????????????????????????????????????????
       ?
       v
????????????????????????????????????????
? Runner->StartDialogue()   ?
? (continues from saved node)  ?
????????????????????????????????????????
```

---

## 6. Error Handling & Recovery

### 6.1. Common Error Scenarios

```cpp
// 1. Asset Load Failure
Problem: DialogueDataAsset not found or corrupted
Recovery:
  - Log error with asset path
  - Broadcast OnDialogueLoadFailed event
  - Transition to Error state
  - UI shows error message
  - Allow retry or cancel

// 2. Invalid Node Reference
Problem: GoToNode() called with non-existent NodeId
Recovery:
  - Log warning with NodeId
  - Try fallback to Start node
  - If fallback fails, end dialogue
  - Create error memory (optional)

// 3. Condition Evaluation Failure
Problem: Condition throws exception or returns invalid result
Recovery:
  - Log error with condition details
  - Treat as false (fail-safe)
  - Skip choice
  - Continue with other choices

// 4. Effect Application Failure
Problem: Effect fails to apply (e.g., component not found)
Recovery:
  - Log warning with effect details
  - Continue with remaining effects
  - Mark effect as failed in history
  - Don't block dialogue progression

// 5. State Machine Violation
Problem: Attempt invalid operation for current state
Recovery:
  - Log error with operation and state
  - Block operation
  - Return false
  - Don't change state

// 6. Pool Exhaustion
Problem: All runners in use, max pool size reached
Recovery:
  - Log warning
- Return nullptr
  - UI shows "busy" message
  - Queue request (optional)
  - Retry after timeout

// 7. AI Provider Failure
Problem: HTTP request fails or times out
Recovery:
  - Log error
  - Fallback to static dialogue
  - Cache last successful response
  - Retry with exponential backoff
```

### 6.2. Debugging Tools

```cpp
// 1. Command History Export
FString UDialogueRunner::GetCommandHistoryAsString() const
{
    if (!CommandInvoker) return TEXT("No history");
    return CommandInvoker->GetHistory()->ExportToString();
}

// Output:
[00:01:23] NavigateToNode: Start ? AskAboutVillage (SUCCESS)
[00:01:45] SelectChoice: "Tell me about the village" (SUCCESS)
[00:02:10] ApplyEffects: ModifyAffinity +10 (SUCCESS)
[00:02:15] NavigateToNode: AskAboutVillage ? Goodbye (SUCCESS)

// 2. State Machine History
TArray<FDialogueStateTransition> GetStateHistory() const
{
    return StateMachine->GetHistory();
}

// Output:
Idle (00:00:00) ? Loading (00:00:01) [Reason: StartDialogue]
Loading (00:00:01) ? Active (00:00:02) [Reason: AssetLoaded]
Active (00:00:02) ? Transitioning (00:00:45) [Reason: SelectChoice]
Transitioning (00:00:45) ? Active (00:00:46) [Reason: NodeProcessed]

// 3. Memory Analysis
void UNPCMemoryTestHelpers::PrintMemories(AActor* NPC)
{
    // See detailed output in NPCMemoryTestHelpers.h
}

// 4. Relationship Stats
void URelationshipComponent::LogStats() const
{
    UE_LOG(LogTemp, Log, TEXT("=== Relationship Stats ==="));
    UE_LOG(LogTemp, Log, TEXT("Affinity: %.1f"), Affinity);
    UE_LOG(LogTemp, Log, TEXT("Trust: %.1f"), Trust);
    UE_LOG(LogTemp, Log, TEXT("Respect: %.1f"), Respect);
    UE_LOG(LogTemp, Log, TEXT("Romance: %.1f"), Romance);
  UE_LOG(LogTemp, Log, TEXT("Fear: %.1f"), Fear);
    UE_LOG(LogTemp, Log, TEXT("Rank: %s"), *GetRelationshipRank().ToString());
    UE_LOG(LogTemp, Log, TEXT("Event History: %d entries"), EventHistory.Num());
}
```

---

## 7. Performance Considerations

### 7.1. Memory Optimization

```cpp
// 1. Object Pooling
- DialogueRunner: ~5KB per instance
- Pool size: 5-20 runners
- Memory saved: ~100KB vs creating on-demand
- GC pressure: Significantly reduced

// 2. Effect Reversal vs Snapshots
- Reversible effect: ~0 bytes (just code)
- Snapshot: ~500 bytes per command
- 90% of effects reversible
- Memory saved: ~450 bytes per command

// 3. Weak Pointers
- Use TWeakObjectPtr for optional references
- Avoids preventing garbage collection
- Example: FDialogueChoice::RelatedActor

// 4. String Optimization
- Use FName for IDs (8 bytes vs 16+ for FString)
- Use FText::FromStringTable for localization
- Avoid FString concatenation in loops

// 5. Asset Loading
- Async loading via FStreamableManager
- Soft object references (TSoftObjectPtr)
- Load on demand, unload when not needed
```

### 7.2. CPU Optimization

```cpp
// 1. Condition Evaluation
- Early-out: && and || short-circuit
- Cache expensive checks
- Example:
  if (bCheapCheck && ExpensiveCheck()) // ExpensiveCheck only if needed

// 2. Component Caching
// BAD:
void SomeMethod()
{
    URelationshipComponent* RelComp = NPC->FindComponentByClass<URelationshipComponent>();
    // Called every frame!
}

// GOOD:
void BeginPlay()
{
    RelationshipComp = NPC->FindComponentByClass<URelationshipComponent>();
}

void SomeMethod()
{
    if (RelationshipComp)
    {
      // Use cached reference
    }
}

// 3. Tick Optimization
- Disable tick when not needed
- Use variable tick intervals
- Example:
  if (!IsInteracting())
  {
      SetComponentTickEnabled(false);
  }

// 4. Memory Decay Optimization
- Update interval: 60 seconds (configurable)
- Batch processing: all memories in one pass
- Skip low-importance memories

// 5. Event Broadcasting
- Use sparse delegates for rare events
- Unbind when not needed
- Example:
  OnDialogueEnded.AddDynamic(this, &UMyClass::Handler);
  // Later:
  OnDialogueEnded.RemoveDynamic(this, &UMyClass::Handler);
```

### 7.3. Network Optimization (Future)

```cpp
// 1. Replication
- Only replicate critical state
- Use delta compression
- Example:
  UPROPERTY(Replicated)
  uint8 CurrentNodeIndex; // 1 byte vs full FName

// 2. RPC Optimization
- Batch multiple operations
- Use unreliable RPCs for non-critical events
- Example:
  UFUNCTION(Server, Unreliable)
  void Server_NotifyNodeChanged(uint8 NodeIndex);

// 3. Event Batching
- Accumulate UI updates
- Send once per frame
- Example:
  TArray<FDialogueUIUpdate> PendingUpdates;
  
  void Tick()
  {
      if (PendingUpdates.Num() > 0)
      {
          BroadcastBatchedUpdates(PendingUpdates);
          PendingUpdates.Empty();
      }
  }
```

---

## ?? Summary

Этот документ предоставляет **детальное описание** всех workflows и integration patterns в Dialogue System.

### Key Takeaways

? **Complete Flow Documentation** - от interaction до cleanup  
? **Integration Patterns** - как системы работают вместе  
? **Authoring Workflows** - DataAsset vs DSL  
? **Error Handling** - recovery strategies  
? **Performance Optimization** - memory, CPU, network  

### Использование

Этот документ предназначен для:
- **Developers** - понимание полного цикла выполнения
- **Designers** - понимание authoring workflow
- **Testers** - понимание error scenarios
- **Architects** - reference для integration patterns

---

**Документ подготовлен:** 2025-01-23  
**Версия:** 1.0  
**Статус:** ? Complete
