# ?? DialogueContext Refactoring Guide

> **v1.3.1:** Refactoring DialogueContext to use Composition Pattern

---

## ?? Goal

Refactor `UDialogueSessionContext` to use composition of:
1. `UDialogueState` - state management
2. `UDialogueParticipants` - participant management
3. `UDialogueVariableStore` - data storage

---

## ?? Changes Required

### 1. DialogueContext.h - Add Composition

```cpp
class DIALOGUESYSTEMCORE_API UDialogueSessionContext : public UObject
{
    GENERATED_BODY()

public:
    //==========================================================================
    // v1.3.1: Component Access (Facade Pattern)
    //==========================================================================

  /** Get state component */
    UFUNCTION(BlueprintPure, Category = "Context")
    UDialogueState* GetState() const { return State; }

    /** Get participants component */
    UFUNCTION(BlueprintPure, Category = "Context")
 UDialogueParticipants* GetParticipants() const { return Participants; }

    /** Get variable store component */
    UFUNCTION(BlueprintPure, Category = "Context")
    UDialogueVariableStore* GetVariables() const { return Variables; }

 //==========================================================================
    // Convenience Delegates to Components
    //==========================================================================

    // State delegates
 UDialogueNode* GetCurrentNode() const { return State->GetCurrentNode(); }
    void SetCurrentNode(UDialogueNode* Node) { State->SetCurrentNode(Node); }
    void MarkNodeVisited(FName NodeId) { State->MarkNodeVisited(NodeId); }
    bool WasNodeVisited(FName NodeId) const { return State->WasNodeVisited(NodeId); }

    // Participant delegates
    AActor* GetPlayer() const { return Participants->GetPlayer(); }
    AActor* GetNPC() const { return Participants->GetNPC(); }
void SetPlayer(AActor* InPlayer) { Participants->SetPlayer(InPlayer); }
 void SetNPC(AActor* InNPC) { Participants->SetNPC(InNPC); }

    // Variable delegates
 void SetCustomVariable(FName Key, const FString& Value) 
    { 
    Variables->SetCustomVariable(Key, Value); 
    }
    FString GetCustomVariable(FName Key, const FString& Default = TEXT("")) const 
    { 
        return Variables->GetCustomVariable(Key, Default); 
    }

    // Type-safe variable delegates (v1.3.1)
    void SetVariantInt(FName Key, int32 Value) { Variables->SetVariantInt(Key, Value); }
int32 GetVariantInt(FName Key, int32 Default = 0) const 
    { 
      return Variables->GetVariantInt(Key, Default); 
    }
    // ... (similar for Bool, Float, String, etc.)

    // Tag delegates
    void AddTag(FGameplayTag Tag) { Variables->AddTag(Tag); }
    void RemoveTag(FGameplayTag Tag) { Variables->RemoveTag(Tag); }
    bool HasTag(FGameplayTag Tag) const { return Variables->HasTag(Tag); }

 //==========================================================================
    // Reset & Snapshot (Unchanged)
    //==========================================================================
  
    void ResetState()
  {
        State->Reset();
 Participants->Reset();
     Variables->Reset();
    }

protected:
    //==========================================================================
    // v1.3.1: Component Composition
    //==========================================================================

    /** Dialogue state component */
    UPROPERTY()
    TObjectPtr<UDialogueState> State;

    /** Participants component */
    UPROPERTY()
    TObjectPtr<UDialogueParticipants> Participants;

    /** Variable store component */
    UPROPERTY()
    TObjectPtr<UDialogueVariableStore> Variables;

    /** LEGACY: Base affinity (delegated to Participants) */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Context")
    float BaseAffinityLevel = 0.0f;
};
```

---

## ?? Implementation Steps

### Step 1: Initialize Components in Constructor

```cpp
// DialogueContext.cpp

UDialogueSessionContext::UDialogueSessionContext()
{
    // Create components (lazy initialization in BeginPlay could be alternative)
  State = CreateDefaultSubobject<UDialogueState>(TEXT("State"));
    Participants = CreateDefaultSubobject<UDialogueParticipants>(TEXT("Participants"));
    Variables = CreateDefaultSubobject<UDialogueVariableStore>(TEXT("Variables"));
}
```

**PROBLEM:** `CreateDefaultSubobject` only works in constructors of Actors/Components!

**SOLUTION:** Use `NewObject` with outer:

```cpp
void UDialogueSessionContext::Initialize()
{
    if (!State)
  {
        State = NewObject<UDialogueState>(this, TEXT("State"));
    }
    if (!Participants)
    {
        Participants = NewObject<UDialogueParticipants>(this, TEXT("Participants"));
    }
if (!Variables)
    {
        Variables = NewObject<UDialogueVariableStore>(this, TEXT("Variables"));
    }
}
```

Call `Initialize()` from:
- DialogueRunner when creating context
- Before first use

---

### Step 2: Update All Methods to Delegate

Example:

**Before:**
```cpp
void UDialogueSessionContext::MarkNodeVisited(FName NodeId)
{
    VisitedNodes.AddUnique(NodeId);
}
```

**After:**
```cpp
void UDialogueSessionContext::MarkNodeVisited(FName NodeId)
{
  State->MarkNodeVisited(NodeId);
}
```

---

### Step 3: Update Snapshot Methods

```cpp
FDialogueStateSnapshot UDialogueSessionContext::CreateSnapshot(uint8 DialogueState, const TArray<UDialogueNode*>& NodeHistory) const
{
    FDialogueStateSnapshot Snapshot;
    
    // Capture from components
    Snapshot.CurrentNodeId = State->GetCurrentNode() ? State->GetCurrentNode()->NodeId : NAME_None;
    Snapshot.VisitedNodes = State->GetVisitedNodes();
    Snapshot.ConversationHistory = State->GetConversationHistory();
    
  // Variables
    Snapshot.CustomVariables.Empty();
    for (FName Key : Variables->GetAllVariableKeys())
    {
        Snapshot.CustomVariables.Add(Key, Variables->GetCustomVariable(Key));
    }
    Snapshot.ActiveTags = Variables->GetActiveTags();
    
    // Participants
    Snapshot.BaseAffinityLevel = Participants->GetBaseAffinityLevel();
    
    // Metadata
    Snapshot.Timestamp = FDateTime::UtcNow();
    Snapshot.DialogueState = DialogueState;
    Snapshot.bIsValid = true;
    
    return Snapshot;
}
```

---

## ? Benefits of Refactoring

1. **SRP Compliance** - Each component has one responsibility
2. **Testability** - Components can be tested independently
3. **Reusability** - Components can be used in other contexts
4. **Maintainability** - Easier to understand and modify
5. **Extensibility** - Easy to add new components
6. **Memory Management** - Better control over lifecycle

---

## ?? Backward Compatibility

All existing public API methods remain unchanged - they just delegate to components.

**No breaking changes for users!**

---

## ?? Migration Path

### For Developers:

**Option A:** Keep using facade methods (recommended)
```cpp
Context->SetCustomVariable(TEXT("Gold"), TEXT("100"));
Context->MarkNodeVisited(TEXT("Node_1"));
```

**Option B:** Access components directly (advanced)
```cpp
Context->GetVariables()->SetVariantInt(TEXT("Gold"), 100);
Context->GetState()->MarkNodeVisited(TEXT("Node_1"));
```

---

## ?? Architecture Comparison

### Before v1.3.1:
```
UDialogueSessionContext (God Object)
??? CurrentNode
??? VisitedNodes
??? ConversationHistory
??? Player
??? NPC
??? CustomVariables
??? TypedVariables
??? ActiveTags
??? 50+ methods
```

### After v1.3.1:
```
UDialogueSessionContext (Facade)
??? UDialogueState
?   ??? CurrentNode
?   ??? VisitedNodes
?   ??? ConversationHistory
??? UDialogueParticipants
?   ??? Player
?   ??? NPC
?   ??? BaseAffinityLevel
??? UDialogueVariableStore
    ??? TypedVariables
    ??? CustomVariables
    ??? ActiveTags
```

---

**Status:** Design document ready  
**Next:** Implement changes in DialogueContext.h/.cpp  
**ETA:** 30-45 minutes
