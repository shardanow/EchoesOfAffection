# ?? v1.7.1 - Automatic Interaction Integration (OUT OF THE BOX!)

## Проблема которую решили

**Раньше:**
- ? Нужно было создавать Blueprint child
- ? Добавлять интерфейс вручную
- ? Реализовывать 3+ функций
- ? Дропнутые items не работали с interaction system

**Теперь:**
- ? Работает из коробки - ZERO setup!
- ? Дропнутые items автоматически interactable
- ? Placed items автоматически interactable
- ? Spawned items автоматически interactable
- ? **NO HARD DEPENDENCIES** - системы полностью независимы!

---

## ?? Как Это Работает (Zero Coupling!)

### Автоматически при BeginPlay:

1. **WorldItemActor проверяет:**
   - Есть ли уже InteractableComponent? (пропускает если есть)
   - Включена ли auto-creation? (`bAutoCreateInteractionComponent = true`)

2. **Если все ОК:**
   - Находит класс `InteractableComponent` в вашем проекте **через имя** (no #include!)
   - Создает компонент динамически **через reflection**
   - Настраивает InteractionData **через property access**
   - **Подписывается на делегаты** компонента

3. **InteractableComponent остается generic:**
   - Ничего не знает про WorldItemActor
   - Работает с любыми actors
   - Можно использовать для doors, NPCs, levers, etc.
   - Просто broadcast'ит события через делегаты

4. **WorldItemActor подписывается на события:**
   - `OnBeginInteract` ? вызывает `PickupItem()`
   - `OnFocused` ? показывает outline (через Blueprint event)
   - Полная гибкость через делегаты!

**Результат:** 
- ? Items просто работают!
- ? Системы независимы!
- ? Можно удалить interaction system - плагин работает!
- ? Можно удалить плагин - interaction system работает!

---

## ??? Архитектура (Zero Coupling)

```
InteractableComponent (Your Project - GENERIC)
??? Properties: InteractionData
??? Delegates: OnBeginInteract, OnFocused, OnUnfocused
??? NO knowledge of WorldItemActor

? (Dynamic Discovery)

WorldItemActor (Plugin - GENERIC)
??? Finds InteractableComponent by name
??? Creates it via NewObject<>()
??? Configures via reflection
??? Subscribes to delegates
??? NO #include of InteractableComponent

? (Runtime Connection)

When player interacts:
??? InteractionComponent detects InteractableComponent
??? Calls BeginInteract()
??? InteractableComponent broadcasts OnBeginInteract
??? WorldItemActor's delegate callback fires
??? Calls PickupItem() ? adds to inventory

```

## ?? Как Работает Binding (Technical Deep Dive)

### Шаг 1: Создание Компонента

```cpp
// WorldItemActor.cpp - TryCreateInteractableComponent()

// Найти класс по имени (без #include!)
UClass* InteractableClass = FindObject<UClass>(
    ANY_PACKAGE, 
    *InteractableComponentClassName
);

// Создать динамически
DynamicInteractableComponent = NewObject<UActorComponent>(
    this, 
    InteractableClass
);

// Зарегистрировать
DynamicInteractableComponent->RegisterComponent();
```

### Шаг 2: Настройка через Reflection

```cpp
// WorldItemActor.cpp - ConfigureInteractionComponent_Implementation()

// Найти свойство InteractionData
FStructProperty* DataProp = CompClass->FindPropertyByName("InteractionData");

// Получить указатель на экземпляр структуры
void* DataPtr = DataProp->ContainerPtrToValuePtr(InteractableComp);

// Найти вложенное свойство (например, InteractionName)
FTextProperty* NameProp = Struct->FindPropertyByName("InteractionName");

// Установить значение
FText* NameValue = NameProp->ContainerPtrToValuePtr(DataPtr);
*NameValue = GetInteractionName();
```

### Шаг 3: Привязка к Делегату (АВТОМАТИЧЕСКИ!)

```cpp
// WorldItemActor.cpp - ConfigureInteractionComponent_Implementation()

// Найти свойство делегата
FProperty* DelegateProp = CompClass->FindPropertyByName("OnBeginInteract");

// Вычислить указатель на делегат с помощью смещения
uint8* ComponentAddress = reinterpret_cast<uint8*>(InteractableComp);
uint8* DelegateAddress = ComponentAddress + DelegateProp->GetOffset_ForInternal();
FMulticastScriptDelegate* DelegateInstance = reinterpret_cast<FMulticastScriptDelegate*>(DelegateAddress);

// Создать привязку
FScriptDelegate Callback;
Callback.BindUFunction(this, "HandleInteractionBegin");

// Добавить в делегат
DelegateInstance->Add(Callback);
```

**Ключевой момент:** Используем `GetOffset_ForInternal()` для вычисления адреса делегата!

### Шаг 4: Обработка Обратного Вызова

```cpp
// WorldItemActor.cpp

void AWorldItemActor::HandleInteractionBegin(AActor* InteractingActor)
{
    // Это вызывается, когда InteractableComponent транслирует OnBeginInteract
    PickupItem(InteractingActor);
}
```

**Результат:** Полная интеграция без единого #include! ?
